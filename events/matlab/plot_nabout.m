function [nabout,filevals,fh] = plot_nabout(fname,figtype,smoothflag,normtype)
%
% Function to plot the marginals from fname (a nab.out file). The data is 
% conveniently returrned into nabout. 
%
% NOTES - currently only deals with the 1D Marginals
%
% INPUTS: 
% fname         [string] full path filename to nab.out file of interest
% figtype       [integer] switch to control type of figures being created
%                   1 = > plot all 1D marginals on the same figure (i.e. subplots)
%                   2 = > plot each 1D marginal in a unique figure
% smoothflag    [vector of integers (2x1): 0 and 1] 
%               The first element controls smoothing for the 1D marginals
%               and the second element controls smoothing for the 2D
%               marginals. The integers do the following
%                   0 => plot the data as it comes out
%                   1 => smooth the curves
%
% normtype      [integer: 0, 1 and 2]
%                   0 => do not do any normalisation (PDFs will integrate to one on unit spacing)
%                   1 => integrate to unit area over bounds of parameters
%                   2 => integrate to maximimum height. 
%
% OUTPUTS: 
% nabout    [structure] contains the marginals and other run info. 
% filevals  [cell vector] with one element per row of the input file
% fh        [structure] contains handles to all of the figures
%
% David Robinson
% 6 October 2009. 

if nargin ==0 
    if strcmp(filesep,'/') % on linux
        fname = '/export/storage/davidr/sandpit/davidr/events/malcolm_nab/NAB/data/nab.out';
    elseif strcmp(filesep,'\')
        fname = 'c:\datafiles\workstuff\sandpit\davidr\events\malcolm_nab\NAB\data\nab.out';
    end
    figtype = 1;
end

% Read the data into a matlab cell with one element per line
% Note that everythings is stored as a string at this stage
fid = fopen(fname);
nabout_tmp1= textscan(fid, '%s', 'delimiter', '\n');
fclose(fid);
nabout_tmp2 = nabout_tmp1{1};

filevals = nabout_tmp2;
nabout = [];
counter = 1;
counter2 = 1;
counter3=1;
NoRS = [];
indlist = [];
indlist_2D = [];
% Loop over the lines and extract the data we want.
for i = 1:size(nabout_tmp2)
   
    % Get the number of model paramaters
    if strncmpi('Number of dimensions', nabout_tmp2{i},20)
        ind = findstr(':',nabout_tmp2{i});
        tmp_str = nabout_tmp2{i}(ind+1:end);
        nabout.ndim = str2num(tmp_str); 
    end
    
    % Get the number of bins used for each 1D marginal
    if strncmpi('Number of bins per axis for 1D marginals', nabout_tmp2{i},40)
        ind = findstr(':',nabout_tmp2{i});
        tmp_str = nabout_tmp2{i}(ind+1:end);
        nabout.n1Dmarginal_bins = str2num(tmp_str); 
    end
    
    % Get the number of bins used for each 2D marginal
    if strncmpi('Number of bins per axis for 2D marginals', nabout_tmp2{i},40)
        ind = findstr(':',nabout_tmp2{i});
        tmp_str = nabout_tmp2{i}(ind+1:end);
        nabout.n2Dmarginal_bins = str2num(tmp_str); 
    end
    
    % Find the place where all of the 1D marginal data starts
    if strncmpi('Number of random samples generated by NA-walks', nabout_tmp2{i},46)
        indlist(counter) = i;
        ind_tmp = findstr(':',nabout_tmp2{i}); 
        NoRS(counter) = str2num(nabout_tmp2{i}(ind_tmp+1:end));
        counter = counter+1;
    end
    
    % Find where all the 2D marginal data starts
    if strncmpi('2D Marginal for parameters', nabout_tmp2{i},26)
        indlist_2D(counter2) = i;
        counter2 = counter2+1;
    end
    
    % Find where all of the covariance matrices start
    if strncmpi('Covariance matrix', nabout_tmp2{i},17)
        indlist_cov(counter3) = i;
        counter3 = counter3+1;
    end
    
end

nabout.NoRS_in_nabout.values = NoRS;
nabout.NoRS_in_nabout.indlist = indlist;
nabout.NoRS_in_nabout.indlist_2D = indlist_2D;

% Now loop over the number of dimensions and read in the 1D marginals. 
% Note that we start the inner loop so that we get the final (most
% detailed) set of marginals
for j = 1: nabout.ndim
    for i = nabout.NoRS_in_nabout.indlist(end):size(nabout_tmp2)
       if strncmpi('Marginal for parameter',nabout_tmp2{i},22)
           ind101 = findstr(nabout_tmp2{i},':');
           dimnumber_tmp = str2num(nabout_tmp2{i}(ind101+1:end));
           if dimnumber_tmp == j
               tmp_1Dmarg = NaN*ones(nabout.n1Dmarginal_bins,2);
               count = 1;
               for k = i+2: i+1+nabout.n1Dmarginal_bins;
                   tmp_str = nabout_tmp2{k};
                   ind = findstr(' ',tmp_str);
                   tmp_1Dmarg(count,1) = str2num(tmp_str(1:ind-1));
                   tmp_1Dmarg(count,2) = str2num(tmp_str(ind+1:end));
                   count = count+1;
               end
               nabout.marginal1D.(['param',num2str(j)]) = tmp_1Dmarg;
               break
           end
       end
    end 
end

% Now let us read in the 2D marginal data
marg2D_starts = indlist_2D(indlist_2D>indlist(end));
pairs = [];
for i = 1:length(marg2D_starts)
    % get the parameter names
    tmp_str = nabout_tmp2{indlist_2D(end - i + 1)};
    ind = findstr(':',tmp_str);  
    par1 = str2num(tmp_str(38:42));
    par2 = str2num(tmp_str(50:end));
    
    % get the bounds for the parameters
    tmp_str = nabout_tmp2{indlist_2D(end - i + 1)+2};
    [numbers] = LOC_read_multidataline(tmp_str);
    par1_bound = numbers(1:2);
    par2_bound = numbers(3:4);
    xvals2D = linspace(par1_bound(1), par1_bound(2),20);
    yvals2D = linspace(par2_bound(1), par2_bound(2),20);
    
    % get the 2D marginal for the parameters
    tmp_data = [];
    for k = 1:(nabout.n2Dmarginal_bins)^2
        tmp_str = nabout_tmp2{indlist_2D(end - i + 1)+3+k};
        if ~isempty(str2num(tmp_str))
            [numbers] = LOC_read_multidataline(tmp_str);
            tmp_data = [tmp_data, numbers];
        else
            break
        end
    end
    
    % Put it into a matrix
    TMP_DATA = zeros(nabout.n2Dmarginal_bins,nabout.n2Dmarginal_bins);
    speccounter = 1;
    for k = 1:nabout.n2Dmarginal_bins 
        TMP_DATA(k,:) = tmp_data(speccounter:speccounter+nabout.n2Dmarginal_bins - 1);
        speccounter = speccounter+nabout.n2Dmarginal_bins;
    end
      
    
    if normtype == 0  % do not re-normalise anything
        tmp_area = 1;
    elseif normtype ==1 % re-normalise so that area = 1 over bounds of each parameter
        tmp_area_vec = trapz(xvals2D',TMP_DATA);
        tmp_area = trapz(yvals2D',tmp_area_vec);
        TMP_DATA = TMP_DATA./tmp_area;
    elseif normtype ==2 % re-normalise to maximum height
        tmp_area = max(max(TMP_DATA));
        TMP_DATA = TMP_DATA/tmp_area;
    else
        error('ERROR: Invalid value for normtype')
    end
    
    
    nabout.marginal2D.(['param',num2str(par1),'_', num2str(par2)]).PDF = TMP_DATA;
    nabout.marginal2D.(['param',num2str(par1),'_', num2str(par2)]).xvals = xvals2D;
    nabout.marginal2D.(['param',num2str(par1),'_', num2str(par2)]).yvals = yvals2D;
    pairs = [pairs; par1, par2];
end
nabout.marginal2D.pairs = pairs;

% Now lets loop over the number of dimesnions and read in the Covariance matrix
cov = zeros(nabout.ndim,nabout.ndim);
row_num = [];
for k = 1:nabout.ndim^2
    tmp_str = nabout_tmp2{indlist_cov(end)+1+k};
    ind = findstr(':',tmp_str);
    if isempty(num2str(tmp_str))  % we must be at the end of the covariance data
        break
    elseif ~isempty(ind) % you are reading in a row title
        if ~isempty(row_num) % you must have some data ready to go
            cov(row_num,:) = row_tmp;
        end
        [row_num] = LOC_read_multidataline(tmp_str);
        row_tmp = [];
    else % you are reading in some row data
        [numbers] = LOC_read_multidataline(tmp_str);
        row_tmp = [row_tmp, numbers];
    end
end
cov(nabout.ndim,:) = row_tmp;
nabout.cov = cov;

% Now let's do the plotting for the 1D marginals
if figtype == 1 % compute the nature of the subplots
    ncols = 3; % we always have ncols
    nrows = ceil(nabout.ndim/ncols); 
end

% plot the 1D marginals
for i = 1:nabout.ndim
    %===========================
    % Step 1 - sort out the figures/subplots
    if figtype ==0
        fh.marginals1D.(['param',num2str(i)])=figure; % open a new figure every time
    elseif figtype ==1
        if i ==1  % open a new figure the first time
            fh.marginals1D.all = figure;
        end
        eval(['subplot(',num2str(nrows),',',num2str(ncols),',',num2str(i),')'])
    end
    %===========================
    % Step 2 - do the plotting
    tmp_marginal_orig = nabout.marginal1D.(['param',num2str(i)]);
    if normtype == 0  % do not re-normalise anything
        tmp_area = 1;
        tmp_marginal = tmp_marginal_orig;
    elseif normtype == 1 % re-normalise so that area = 1 over bounds of each parameter
        tmp_area = trapz(tmp_marginal_orig(:,1), tmp_marginal_orig(:,2));
        tmp_marginal = tmp_marginal_orig;
        tmp_marginal(:,2) = tmp_marginal(:,2)/tmp_area;
    elseif normtype ==2 % re-normalise to maximum height
        tmp_area = max(tmp_marginal_orig(:,1));
        tmp_marginal = tmp_marginal_orig;
        tmp_marginal(:,2) = tmp_marginal(:,2)/tmp_area;
    else
        error('ERROR: Invalid value for normtype')
    end
    
    if smoothflag(1) ==0
        plot(tmp_marginal(:,1),tmp_marginal(:,2),'k','linewidth',2)
        hold on
        plot(tmp_marginal(:,1),tmp_marginal(:,2),'k.')
    elseif smoothflag(1) ==1
         xorig = tmp_marginal(:,1);
         yorig = tmp_marginal(:,2);
%         xnew = linspace(min(xorig),max(xorig), 100);
%         ynew = spline(xorig,yorig,xnew);
%        plot(xnew,ynew,'linewidth',2)
         ynew = running_means5(yorig);
          plot(xorig,ynew,'k','linewidth',2)
          nabout.marginal1Dsmooth.(['param',num2str(i)]) = [xorig,ynew];
%         hold on
%         plot(tmp_marginal(:,1),tmp_marginal(:,2),'r')
                  
    else
        error('ERROR: invalid value for smoothflag')
    end
    ylabel(['P(x',num2str(i),')'])
    
end

% plot the 2D marginals
[npairs,mpairs] = size(nabout.marginal2D.pairs);
for i = 1:npairs
    pairname = ['param',num2str(pairs(i,1)),'_',num2str(pairs(i,2))];
    xvals_tmp = nabout.marginal2D.(pairname).xvals; 
    yvals_tmp = nabout.marginal2D.(pairname).yvals; 
    PDF_tmp = nabout.marginal2D.(pairname).PDF; 
    
    % do smoothing using 3x3 running means if requested
    if smoothflag(2) ==1
            PDF_tmp = Smooth2D(PDF_tmp); 
    end 
     
    
    if smoothflag(2) ==0  % draw the contours with no smoothing
        tmpof_PDF_tmp = PDF_tmp;
        tmpof_xvals_tmp = xvals_tmp;
        tmpof_yvals_tmp = yvals_tmp;
    elseif smoothflag(2) ==3  % make smooth contours using inter2 4 times recursively
        tmpof_PDF_tmp = interp2(PDF_tmp,4);
        [ntmp,mtmp] = size(tmpof_PDF_tmp);
        tmpof_xvals_tmp = linspace(min(xvals_tmp),max(xvals_tmp), ntmp);
        tmpof_yvals_tmp = linspace(min(yvals_tmp),max(yvals_tmp), mtmp);
    end
    
    % Note that we use the coarse deat for the perspective plot
    fh.marginals2D.(pairname)=figure;
    surf(xvals_tmp,yvals_tmp,PDF_tmp)
    xlabel(['x',num2str(nabout.marginal2D.pairs(i,1))])
    ylabel(['x',num2str(nabout.marginal2D.pairs(i,2))])
    
    % Now we use the finer/smoother data for the contour plots
    fh.marginals2D_contour.(pairname) = figure; 
    contour(tmpof_xvals_tmp,tmpof_yvals_tmp,tmpof_PDF_tmp)       
    xlabel(['x',num2str(nabout.marginal2D.pairs(i,1))])
    ylabel(['x',num2str(nabout.marginal2D.pairs(i,2))])
    set(gca,'xlim',[min(xvals_tmp), max(xvals_tmp)], 'ylim', [min(yvals_tmp), max(yvals_tmp)])
    % Add on the 95% CI
    CI = 0.68;
    deltax = xvals_tmp(2)- xvals_tmp(1);
    deltay = yvals_tmp(2) - yvals_tmp(1);
    allvals = PDF_tmp(:);
    allvals_sorted = sort(allvals,'descend');
    cumsum_allvalls_sorted = cumsum(allvals_sorted.*deltax.*deltay);
    cumsum_allvalls_sorted = cumsum_allvalls_sorted/cumsum_allvalls_sorted(end); % this subtle adjustment ensures that the cumsum ==1 (note before this the integral ==1)
    ind1 = find(cumsum_allvalls_sorted>CI);
    fval_oi = interp1( ...
        [cumsum_allvalls_sorted(ind1(1)), cumsum_allvalls_sorted(ind1(1)-1)], ...
        [allvals_sorted(ind1(1)), allvals_sorted(ind1(1)-1)], ...
        CI);
    hold on
    contour(xvals_tmp,yvals_tmp,PDF_tmp, fval_oi,'color','k','linewidth',2)
end

% plot the covariance matrix
fh.cov = figure;
imagesc(nabout.cov)
colorbar
title('covariance matrix')
xticklocs = 1: nabout.ndim;
for i = 1:nabout.ndim
   xticklables{i} =['x',num2str(i)]; 
end
set(gca,'xtick', xticklocs,'xtickLabel',xticklables)
set(gca,'ytick', xticklocs,'ytickLabel',xticklables)

% Compute and plot the correlation matrix
fh.corr = figure;
covMat = nabout.cov;
Var1 = repmat(diag(covMat)',6,1);
Var2 = repmat(diag(covMat),1,6);
nabout.corr = covMat./sqrt(Var1.*Var2);
imagesc(nabout.corr,[-1 1])
colorbar
title('correlation matrix')
xticklocs = 1: nabout.ndim;
for i = 1:nabout.ndim
   xticklables{i} =['x',num2str(i)]; 
end
set(gca,'xtick', xticklocs,'xtickLabel',xticklables)
set(gca,'ytick', xticklocs,'ytickLabel',xticklables)



function [numbers] = LOC_read_multidataline(tmp_str)
ind = findstr(' ',tmp_str);

if isempty(ind)  % there is only one number
    numbers = str2num(tmp_str);
else % there is potentially several numbers
    numbers = [];
    tmp_str2 = tmp_str(1:ind(1)-1);
    numbers = str2num(tmp_str2);
    for j = 1:length(ind)-1
        tmp_str2 = tmp_str(ind(j):ind(j+1));
        if ~isempty(str2num(tmp_str2))
            numbers = [numbers, str2num(tmp_str2)];
        end
    end
    numbers = [numbers, str2num(tmp_str(ind(end):end))];
end

